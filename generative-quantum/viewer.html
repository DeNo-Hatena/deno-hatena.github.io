<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Viewer | Still Latency</title>
  <style>
    :root{
      --bg:#0b0d10;
      --fg:#e8e8e8;
      --muted:#a9b0bb;
      --line:#2a2f38;
      --link:#c7d2ff;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);}
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                   "Noto Sans JP","Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    }
    a{color:var(--link);text-decoration:none;}
    a:hover{text-decoration:underline;}
    button{
      background:transparent;border:1px solid var(--line);color:var(--fg);
      padding:8px 10px;border-radius:10px;cursor:pointer;
    }
    button:hover{border-color:#3a4150;}

    .wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr;}
    header{
      display:flex;align-items:center;justify-content:space-between;
      padding:14px 18px;border-bottom:1px solid var(--line);
      background:rgba(11,13,16,.72);backdrop-filter: blur(10px);
    }
    header .left{display:flex;gap:12px;align-items:baseline;flex-wrap:wrap;}
    header .title{font-size:14px;letter-spacing:.02em;}
    header .desc{font-size:12px;color:var(--muted);}
    header .right{display:flex;gap:10px;align-items:center;font-size:12px;color:var(--muted);}

    .stage{position:relative;min-height:0;}
    canvas{display:block;width:100%;height:100%;}
    .overlay{
      position:absolute;left:18px;bottom:14px;
      color:rgba(255,255,255,.60);
      font-size:12px;line-height:1.45;
      pointer-events:none;user-select:none;
      text-shadow: 0 1px 12px rgba(0,0,0,.65);
      max-width: 60ch;
    }
    .badge{
      display:inline-block;
      padding:2px 8px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      color:rgba(255,255,255,.70);
      background:rgba(0,0,0,.18);
      margin-right:6px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="left">
        <div class="title" id="workTitle">Viewer</div>
        <div class="desc" id="workDesc">未観測：内部状態だけが進む</div>
      </div>
      <div class="right">
        <a href="./">← Gallery</a>
        <button id="generate" title="この個室で一度だけ観測して確定する">生成（観測）</button>
        <button id="regen" title="この個室をリロードして未観測へ戻す">別世界（リロード）</button>
      </div>
    </header>

    <section class="stage">
      <canvas id="c"></canvas>
      <div class="overlay" id="overlay">
        <span class="badge">unobserved</span>
        まだ何も確定していない。<br>
        「生成（観測）」を押すと、この瞬間の世界が静止画として確定する。
      </div>
    </section>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const workTitle = document.getElementById("workTitle");
  const workDesc  = document.getElementById("workDesc");
  const overlay   = document.getElementById("overlay");

  document.getElementById("regen").addEventListener("click", () => location.reload());

  // =========================================================
  // Works
  // =========================================================
  const WORKS = [
    { id:"flowfield", title:"Flow Field", desc:"場に沿って筆致が流れる", renderer: renderFlowField },
    { id:"rings",     title:"Rings",     desc:"干渉縞のような円環",     renderer: renderRings },
    { id:"shards",    title:"Shards",    desc:"割れた光片の抽象構成",   renderer: renderShards },
  ];

  // URLで作品を指定：viewer.html?work=rings
  const params = new URLSearchParams(location.search);
  const workId = params.get("work") || "flowfield";
  const work = WORKS.find(w => w.id === workId) || WORKS[0];

  workTitle.textContent = work.title;
  workDesc.textContent  = "未観測：内部状態だけが進む";

  // =========================================================
  // Unobserved drift
  // =========================================================
  let state = makeState();
  let observed = false;
  let unobservedTimer = setInterval(() => {
    if (observed) return;
    state.t += 0.016;
    drift(state);
  }, 16);

  // 観測（確定）
  document.getElementById("generate").addEventListener("click", () => {
    if (observed) return;
    observeNow();
  });

  function observeNow(){
    observed = true;
    clearInterval(unobservedTimer);

    overlay.innerHTML = `
      <span class="badge">observed</span>
      確定：${escapeHtml(work.title)}<br>
      （再生成するにはリロード）
    `;
    workDesc.textContent = "観測：この瞬間の世界が確定した";

    resize();

    const observedState = structuredClone(state);
    observedState.viewer = { w: innerWidth, h: innerHeight, dpr: devicePixelRatio || 1 };

    try{
      work.renderer(ctx, innerWidth, innerHeight, observedState, { isThumb:false });
    }catch(e){
      console.error("[main render failed]", work.id, e);
      // フォールバック：真っ黒にしない
      ctx.fillStyle = "rgb(10,12,16)";
      ctx.fillRect(0,0,innerWidth,innerHeight);
      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.lineWidth = 2;
      ctx.strokeRect(24, 24, innerWidth-48, innerHeight-48);
      overlay.innerHTML += `<br><span style="color:rgba(255,180,180,.8)">生成に失敗（Console参照）</span>`;
    }
  }

  // リサイズは世界の再計算になるので無視（不可逆性）
  window.addEventListener("resize", () => { /* intentionally empty */ });

  // 初期はキャンバスを背景色で埋めておく（“何もない”を気持ち良く）
  paintIdle();

  function paintIdle(){
    resize();
    ctx.fillStyle = "rgb(10,12,16)";
    ctx.fillRect(0,0,innerWidth,innerHeight);
    ctx.globalAlpha = 0.05;
    grain(ctx, innerWidth, innerHeight, state.seed);
    ctx.globalAlpha = 1;
  }

  function resize(){
    const dpr = devicePixelRatio || 1;
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  // =========================================================
  // State / Palette
  // =========================================================
  function makeState(){
    const seed = (Math.random()*1e9) >>> 0;
    return {
      seed,
      t: Math.random()*1000,
      field: {
        a: 0.6 + Math.random()*1.2,
        b: 0.6 + Math.random()*1.2,
        c: 0.6 + Math.random()*1.2,
        d: 0.6 + Math.random()*1.2
      },
      palette: makePalette(seed)
    };
  }

  function drift(s){
    const r = mulberry32(s.seed + Math.floor(s.t * 60));
    s.field.a += (r()-0.5) * 0.002;
    s.field.b += (r()-0.5) * 0.002;
    s.field.c += (r()-0.5) * 0.002;
    s.field.d += (r()-0.5) * 0.002;
  }

  function makePalette(seed){
    const inks = [
      "rgba(199,210,255,1)",
      "rgba(255,210,199,1)",
      "rgba(199,255,233,1)",
      "rgba(255,255,255,1)"
    ];
    return { bg:"rgb(10,12,16)", ink: shuffle(inks, seed).slice(0,3) };
  }

  // =========================================================
  // Renderers
  // =========================================================
  function renderFlowField(ctx, W, H, s, opt){
    ctx.fillStyle = s.palette.bg;
    ctx.fillRect(0,0,W,H);

    const particles = makeParticles(W, H, Math.floor((W*H)/1200), s.seed);

    ctx.globalCompositeOperation = "lighter";
    ctx.lineWidth = Math.max(0.6, Math.min(W,H)*0.0012);

    for (let layer=0; layer<3; layer++){
      ctx.strokeStyle = s.palette.ink[layer % s.palette.ink.length];
      ctx.globalAlpha = 0.20 + layer*0.12;

      for (let i=0; i<particles.length; i++){
        drawFlowStroke(ctx, particles[i], s, W, H, 70 + layer*30);
      }
    }

    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 0.06;
    grain(ctx, W, H, s.seed);
    ctx.globalAlpha = 1;
  }

  function drawFlowStroke(ctx, p, s, W, H, steps){
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);

    let x=p.x, y=p.y;
    const t0=s.t;

    for (let k=0; k<steps; k++){
      const v = fieldVec(x,y,t0,s,W,H);
      x += v.vx;
      y += v.vy;
      if (x<-20 || y<-20 || x>W+20 || y>H+20) break;
      ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  function fieldVec(x,y,t,s,W,H){
    const nx=(x/W)*2-1;
    const ny=(y/H)*2-1;

    const f=s.field;
    const u = Math.sin((nx*f.a + t*0.7)*Math.PI) + Math.cos((ny*f.b - t*0.5)*Math.PI);
    const v = Math.cos((ny*f.c + t*0.6)*Math.PI) - Math.sin((nx*f.d - t*0.4)*Math.PI);

    const ang = Math.atan2(v,u);
    const mag = 1.2 + 0.9*(Math.sin(u*1.3)*Math.cos(v*1.1));
    const sp  = Math.min(W,H)*0.0022;

    return { vx: Math.cos(ang)*mag*sp, vy: Math.sin(ang)*mag*sp };
  }

  function renderRings(ctx, W, H, s, opt){
    ctx.fillStyle = s.palette.bg;
    ctx.fillRect(0,0,W,H);

    const rnd = mulberry32(s.seed);
    const cx = W*(0.35 + rnd()*0.30);
    const cy = H*(0.35 + rnd()*0.30);

    ctx.globalCompositeOperation = "screen";
    ctx.lineWidth = Math.max(1.2, Math.min(W,H)*0.0018);

    const step  = Math.max(6, Math.min(W,H)/120);
    const rings = Math.floor(Math.min(W,H)/step);

    for (let i=0; i<rings; i++){
      const baseR  = i*step;
      const jitter = (rnd()-0.5) * step * 0.6;
      const r = Math.max(0.15, baseR + jitter); // ★必ず正

      const t = i / rings;
      const centerBoost = 1.0 - 0.65*t;
      const w = 0.5 + 0.7*Math.sin(i*0.15 + s.t);

      ctx.strokeStyle = s.palette.ink[i % s.palette.ink.length];
      ctx.globalAlpha = Math.max(0.06, (0.16 + 0.22*w) * centerBoost);

      ctx.beginPath();
      ctx.ellipse(
        cx, cy,
        r*(1.0 + 0.08*Math.sin(i*0.07)),
        r,
        (rnd()-0.5)*0.2,
        0, Math.PI*2
      );
      ctx.stroke();
    }

    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 0.06;
    grain(ctx, W, H, s.seed);
    ctx.globalAlpha = 1;
  }

  function renderShards(ctx, W, H, s, opt){
    ctx.fillStyle = s.palette.bg;
    ctx.fillRect(0,0,W,H);

    const rnd = mulberry32(s.seed);
    ctx.globalCompositeOperation = "lighter";

    const n = Math.max(18, Math.floor((W*H)/25000));

    for (let i=0; i<n; i++){
      const x=rnd()*W, y=rnd()*H;
      const size = 30 + rnd()*180;
      const ang = rnd()*Math.PI*2;

      ctx.fillStyle = s.palette.ink[i % s.palette.ink.length];
      ctx.globalAlpha = 0.08 + rnd()*0.14;

      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(ang);
      ctx.beginPath();
      ctx.moveTo(-size*0.5, -size*0.2);
      ctx.lineTo( size*0.55, -size*0.05);
      ctx.lineTo( size*0.25,  size*0.35);
      ctx.lineTo(-size*0.45,  size*0.25);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 0.06;
    grain(ctx, W, H, s.seed);
    ctx.globalAlpha = 1;
  }

  // =========================================================
  // Utils
  // =========================================================
  function makeParticles(W,H,n,seed){
    const rnd = mulberry32(seed);
    const ps = new Array(n);
    for (let i=0; i<n; i++) ps[i] = { x:rnd()*W, y:rnd()*H };
    return ps;
  }

  function grain(ctx, W, H, seed){
    const rnd = mulberry32(seed + 12345);
    const count = Math.floor((W*H)/8000);
    ctx.fillStyle = "white";
    for (let i=0; i<count; i++) ctx.fillRect(rnd()*W, rnd()*H, 1, 1);
  }

  function mulberry32(a){
    a = (a >>> 0);
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function shuffle(arr, seed){
    const rnd = mulberry32(seed);
    const a = arr.slice();
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(rnd()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function escapeHtml(str){
    return String(str)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
})();
</script>
</body>
</html>
